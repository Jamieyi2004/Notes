# 认识存储&数据库
## 经典案例 
- 一条数据从产生，到数据流动，最后持久化的全生命周期
- 小明注册新账号，填好资料后提交，数据就从无到头产生了。
- 客户端传到服务器，再传到数据库，还可能传到其他系统
- 持久化：1. 校验数据的合法性 2.修改内存，用高效的数据解构组织数据 3. 写入存储介质 以寿命&性能友好的方式写入硬件
- 潜在问题：数据不丢？如何处理多用户写？除了数据库还有其他存储系统么？数据库只能处理结构化的数据么？操作方式编程语言？ 
## 存储&数据库 简介
- 从逻辑上看，存储系统位于较低层，而数据库则构建在其之上。存储系统提供了基本的读写接口，而数据库则在此基础上增加了更高层次的数据管理和访问功能。

存储系统
- 什么是存储系统？ 一个提供了读写、控制类接口，能够安全地把数据库持久化的软件，就可以称为存储系统。块存储 文件存储 对象存储 kv存储
- 系统特点？ 性能敏感，代码既简单（保证性能）又复杂（多种IO异常），容易受硬件影响
- 怎么持久化？缓存很重要，贯彻整个存储体系（粒度不同...）； 拷贝很昂贵，应该尽量减少；需要抽象统一的接入层。
- RAID技术 Redundant, Array, Inexpensive, Disks 1. RAID0多块磁盘简单组合，提高磁盘带宽，没有额外的容错设计 2. RAID1 真实空间利用率低容错能力强 3. RAID 0 +1   
数据库
- 关系型数据库是存储系统，但是在存储之外，有发展出其他能力，结构化数据友好，支持事物，支持复杂查询语言（关系型数据库中的“关系”指的是数据表之间通过某些共同的属性或字段建立的逻辑关联。）
- 非关系型数据库也是存储系统，一般不要求不要求严格结构化 半结构化数据友好，可能支持事务，可能支持复杂查询语言
- 事务 ACID 原子性一致性隔离性持久性
## 主流产品剖析
### 单机存储
单个计算机节点上的存储软件系统，一般不涉及网络交互
- 本地文件系统
Linux 一切皆文件 两大数据结构 Index Node(记录文件元数据，唯一标识) & Directory Entry（记录文件名，inode指针，层级关系）
文件系统种类繁多，但都遵循统一的抽象接口
- kv存储
世间一切皆kv
put(k,v) & get(k)
常见数据结构：LSM-Tree 牺牲读性能，追求写性能
拳头产品：RocksDB
### 分布式存储
实现分布式协议
- 分布式文件存储系统
HDFS 基于Dadoop 支持海量数据存储，高容错性，弱POSIX语义，性价比高。


Hadoop 主要关注的是如何在一个分布式环境中有效地存储和处理大量的数据。它的设计重点在于容错性和可扩展性，适用于批处理和流处理的大数据分析任务。
Raft 则专注于解决分布式系统中的一致性问题，特别是如何在多个节点之间达成共识，保证数据的一致性和可靠性。它通常应用于需要强一致性的场景，例如分布式数据库或键值存储系统中的元数据管理。

- Ceph 一切皆对象 主备复制模型   
### 单机sql
商业产品Oracle称王，开源产品MySQL&PostgreSQL称王
### 单机nosql
MongoDB、Redis、Elasticsearch(能支持模糊搜索)
### 分布式数据库
单点容量有限，受硬件限制 -> 存储节点池化，动态扩缩容
弹性、性价比

单写 vs 多些？ 内存弹性？ 分布式事务优化？


# 高质量编程 & 编程规范
## 代码格式
推荐使用gofmt自动格式化代码
## 注释
- 代码作用
- 实现逻辑
- 实现原因
- 什么情况出错
## 变量命名规范
- Go语言遵循驼峰命名法（CamelCase），推荐使用有意义的英文名称来提高代码的可读性和可维护性。避免使用下划线作为单词分隔符。
- 简介
- 缩略全大写，但位于变量开头且不需要到导出的时候使用全小写
    - ServeHTTP
    - XMLHTTPRequest or xmlHTTPRequest
    - 全局变量距离其被使用的地方越远，则需要提供更多的上下文信息
## 函数命名规范
- 导出的首字母大写
- 不携带包名的上下文
- 简短
- 如果和包名不一致，可以加入类型信息
## 包
- 只由小写字母组成
- 使用单数 不用常见变量名 标准库名

## 控制流程
- 尽量保持正常代码路径为最小缩减
- 有限处理错误、特殊情况，尽早返回  

## 错误和异常处理
- 简单错误
优先使用errors.New来创建匿名变量来直接表示简单错误;如果有格式化的需求，使用fmt.Errorf.
```go
return errors.New("error message")
```

## defer 
- 函数返回前调用
- 后进先出  
# 编程性能优化 
## 语句 
```go test -bench=. -benchmem```
## Slice 预分配内存
尽可能在使用make()初始化切片的时候提供容量信息
```data := make([]int, 0, size)```
- 切片本质上是一个数组片段的描述 包含数组指针、片段长度、片段容量
- 切片操作并不复制切片指向的值
- 常见一个新的切片会复用原来切片的底层数组  
## slice另一个陷阱 大内存未释放
- 原切片较大，代码在原切片基础上新建小切片
- 原底层数组在内存中有引用，得不到释放
- 可使用copy解决
## Map预分配内存

## 字符串拼接
使用 + 拼接性能最差，string.Builder, bytes.Buffer相近，Buffer快点。 
- 字符串在Go语言中是不可变类型（不能修改单个字符、不能使用切片改变原字符串、拼接生成新字符串、使用内置函数修改字符串），占用内存大小是固定的
- 使用 + 会重新分配内存
- 而另外两个底层是[]byte数组
- 内容扩充策略，不需要每次拼接重新分配内存

## 使用空结构体节省内存
- 不占据内存空间
```tmp = struct{}{}```
- 本身具备很强的语义,即这里不需要任何值 
- 实现set

# 性能分析工具
pprof是用于可视化和性能分析数据的工具